+++
author = ""
date = "2020-05-14T01:50:00+08:00"
description = ""
draft = false
highlight = false
tags = []
title = "《架构整洁之道》读书笔记"
categories = ["架构"]
tocCollapseDepth = 2
+++

## 第 1 部分: 概述
### 第 1 章: 设计与架构究竟是什么
> 架构即设计

#### 目标是什么
> “软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。”

如果按后面主题来看的话，这个关注视角可能过于局限。软件架构的目标是这个我赞同，但是放到全局，企业的目标就是盈利...

##### 问题到底在哪里
> 工程师（有意无意地）自我欺骗：“我们可以未来再重构代码，产品上线最重要！” ── P9

这可能需要制度的变化才能有所改观，指标需要重定义。

> “无论是从短期还是长期来看，胡乱编写代码的工作速度其实比循规蹈矩更慢。” ── P9

> “如果你觉得好架构的成本太高，那你可以试试选择差的架构加上返工重来的成本。” ── 序言 XII

> “想要跑得快，先要跑得稳。”

这里可能道理大家都懂，但是缺乏具有实操性的指导原则：都知道要适应变化，但是又如何保证不**过度设计**呢？什么是过度设计，比如力求一切可变灵活，那肯定是过度设计。

举一个简单例子，我们现在有很多基于 IP 不变假设的设计，如果一开始就试图适应可变 IP，需要花费相当可观的开发人力；但是如果不适应，一旦 IP 需要变更，将是一场灾难。

如何识别未来的潜在变化是个永恒的议题。如果没有明确的指导方法，仅靠一切尽在不言中，就难以长久维持良好的架构（设计）。


实践矩阵

| | 开发快 | 开发慢 |
| --- | --- | ---|
| 好架构 | **我们想要的**  | 通常选项
| 坏架构 | 通常选项  | 渣渣

实践发现，我们的困扰正是来自于二者不可得兼。如何才能开发又快架构又好呢，目前看来，只能多读书多练习多总结，输出更多的经验模式，才更容易扩展复制成功的架构。



### 第 2 章: 两个价值维度
> 软件的实际价值由两个维度体现：行为和架构

#### 行为价值
> 程序员不应该认为实现需求就是全部工作

#### 架构价值
> 软件的 “软”，“不言而喻，是指软件的灵活性”

> “软件应该容易被修改” 
“变更实施的难度应该和变更的范畴（scope）成等比关系，而与变更的具体形状（shape）无关”


#### 哪个价值维度更重要
> 行为价值并非比架构价值更重要
作者用的论据是：

软件价值矩阵

|  | 正常工作 | 不正常工作 |
| --- | --- | --- |
| 易于修改 | 价值满满 | 持续产生价值  
| 无法修改 | 0 | 0

但是作者也坦然承认，绝对无法修改的软件时不存在的。

这个得看赛场，有些赛场可能就是 “天下武功，唯快不破”。比如创业公司甚至可能撑不到良好架构获取真正价值的那一天就已经死亡。但是要注意，本书作者也并没有下结论说架构价值比行为价值更重要。

#### 艾森豪威尔矩阵
推荐排序

| | 重要 | 不重要 |
| --- | --- | --- |
| 紧急 | 1 | 3
| 不紧急 | 2 | 4

> 业务部门和研发人员经常犯的共同错误就是将第三优先级的事情提到第一优先级去做。

也就是说作者认为重要的事优先于紧急的事情。

> 业务部门没有能力评估系统架构的重要程度

> “平衡系统架构的重要性与功能的紧急程度这件事，是软件研发人员自己的职责。”


#### 为好的软件架构而持续斗争
> “公司内部的抗争本来就是无止境的”

这句我赞同，其实需要各方的尽力竞争才能形成最优的合作。内耗是固有存在的，就像做功永远会有能量损失。但是个人认为这个部分**可以优化**。这里可能业务部门和研发人员的目标可以有一定的融合。有点像 Google SRE 实践中，让运维与开发的目标适度统一，其实本来就不必对立。比方说如果运维的目标就是稳定，那就不能允许开发进行变更；但开发人员只关注功能发布，就需要频繁变更。那么 Google 的做法是设置错误预算来调和双方目标。

## 第 2 部分: 从基础构件开始: 编程范式
> “直到今天，我们也一共只有三个编程范式，而且未来几乎不可能再出现新的”

### 第 3 章: 编程范式总览
| 范式 | 限制和规范 | 关注点 | 手段 |
| --- | --- | --- | --- |
结构化编程 | 程序控制权的直接转移（goto 语句） | 功能性 | 各模块算法实现基础
面向对象编程 | 程序控制权的间接转移（函数指针） | 组件独立性 | 多态跨越架构边界
函数式编程 | 程序中的赋值（赋值语句） | 数据管理 | 规范和限制数据存放位置与访问权限

> “我们过去 50 年学到的东西主要是 ── 什么不应该做。” ── P51

代码是写给人看的，而人的认知能力有限（内存太小），因此需要保持尽量简单。不同范式其实表达能力是一样的（图灵等价），那么其实说三种范式的实质是限制和规范（从作者关注点的视角），就不难理解，其实是一种避免多样、混乱和复杂的方式。

这种约束和 KISS、“如无必要，勿增实体”、奥卡姆剃刀等原则的本质是一样的，力求熵减。

应该说良好的架构亦是如此，规范和限制，明确表达什么不能做。

> “无论是三种编程范式还是微服务架构，它们都在解决一个问题 ── **分离控制和逻辑**” ── 推荐序一 V

逻辑描述做什么，也就是不变的部分。
控制描述怎么做，也就是变化的部分。

编程范式的解耦方式
* 面向对象：委托、策略、桥接、修饰、IoC/DIP、MVC
* 函数式编程：修饰、管道、拼装
* 逻辑推导式编程：Prolog

“为什么要从编程范式开始谈起？在审阅完整本书过程中，我慢慢发现鲍勃大叔其实在传递一种设计理念：架构设计里，自顶向下的设计往往是不靠谱的。就连本书的目录也在言说同样的逻辑，从程序的基础构件，谈到组件，最后才谈到架构，这个涌现的过程非常符合《系统之美》中描述的系统的自组织特征。”


### 第 4 章: 结构化编程
> “goto 语句的**某些**用法会导致某个模块无法被递归拆分成更小的，可证明的单元，这会导致无法采用分解法来将大型问题进一步拆分成更小的、可证明的部分。”

哪些用法？

> 系统设计层次混乱，也可以看作一种 “goto” 陷阱 ── 推荐序二 VII

> “结构化编程范式中最有价值的地方就是，它赋予了我们创造可证伪程序单元的能力。”

> 功能性降解拆分仍然是架构设计领域最佳实践之一。

正是因为可递归降解，通过无法证伪（通过测试）子单元函数，从而可推导整个程序正确。


### 第 5 章: 面向对象编程
#### 封装
封装的思想可以理解为屏蔽不必要的信息，这里又是熵减的目标。

> “这个特性其实并不是面向对象编程所独有的。”

> 相比于 C，C++、Java、C# 这种 “面向对象” 语言反而削弱了封装性。
really?

> “我们很难说强封装是面向对象编程的必要条件。”

#### 继承
继承是一种复用实现（函数和变量）的方式。

> C 也可以做继承（有些投机取巧）

> 但是面向对象编程对继承提供了易用便利

#### 多态
> C 也可以做多态，“归根到底，多态其实不过就是函数指针的一种应用。”

> 但是面向对象编程确实使多态更安全更易用

##### 多态的强大性
多态解耦了声明与实现。这种解耦是通过函数指针间接找到目标函数完成。

> 多态可以实现插件式架构，而面向对象编程使得插件式架构可以在任何地方被安全地使用。

可以理解为面向对象编程规范了多态的实现。

##### 依赖反转
> 依赖关系和控制流相反则称为**依赖反转**。

> 通过利用面向对象编程语言所提供的安全便利的多态实现，可以完全控制所有源码依赖关系，不受系统控制流的限制

重点是依赖于抽象（更稳定的部分），无论高低层次。这样也就实现了控制与逻辑分离。抽象=逻辑，实现=控制。

> 完全控制源码依赖关系的好处是可以独立编译，进而推导出可以独立部署，进而推导出可以独立开发
切入角度刁钻。

#### 小结
> “面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。”

### 第 6 章: 函数式编程
函数式编程不允许重复赋值。“Neal Ford在《函数式编程思想》（Functional Thinking）中提到面向对象编程是通过封装可变因素控制复杂性（makes code understandable），而函数式编程是通过消除可变因素控制复杂性的。”

“像 Scala，Clojure 这些基于JVM上的函数式编程语言大量使用了持久化结构（如：Persistent Vector)，在不损失效率的前提下，实现了不可变的数据结构。这样的数据结构在高并发的环境下具有非常巨大的优势，尤其相对于面向对象编程中为人所诟病的临界区和竞态条件。”

#### 可变性的隔离
> “一个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量。”

> “可变状态组件的逻辑应该越少越好。”

#### 事件溯源
> 举了 binlog CRUD=>CR 的例子

可参考 [日志：每个软件工程师都应该知道的有关实时数据的统一抽象](https://github.com/oldratlee/translations/blob/master/log-what-every-software-engineer-should-know-about-real-time-datas-unifying/README.md)

## 第 3 部分：设计原则
构建中层软件结构（模块级编程）的主要目标：
* 易扩展
    > 可容忍被改动
* 易复用
    > 组件可在多个软件中复用
* 易理解

这里个人的理解是 “易复用” 和 “易理解” 其实都是为了 “易扩展”，说这么多，还是为了──适应变化。

<!-- 兴许可以加上可维护这个目标？但是可维护也就是想要修改，但悖论是不看代码又怎么知道需要修改了？ -->

**SOLID** 原则：
* **S**RP: 单一职责原则
    > “康威定律的一个推论”，使得 “，每个软件模块都有且只有一个需要被改变的理由”
* **O**CP: 开闭原则
    > “允许新增代码来修改系统行为，而非只能靠修改原来的代码”
* **L**SP: 里氏替换原则
    > 组件应遵守相同约定以便可以互相替换
* **I**SP: 接口隔离原则
    > “避免不必要的依赖”
* **D**IP: 依赖反转原则
    > 底层细节代码应该依赖高层策略代码

> SOLID 原则主要指导如何将数据和函数组织成类（分组），以及如何将类链接为程序

> “SOLID 原则应该直接紧贴于具体的代码逻辑之上”，主要适用于模块级编程

### 第 7 章：SRP: 单一职责原则
> 面向底层实现细节的设计原则：“每个模块都应该只做一件事” 并非 SRP 的全部

> “任何一个软件模块都应该有且仅有一个被修改的原因”

SRP 也可以体现在单条语句上，一个真实的例子：
```python
sheet.column_dimensions['A'].width = 3.25
sheet.column_dimensions['B'].width = 1.38
sheet.column_dimensions['C'].width = 3.63
sheet.column_dimensions['D'].width = 5
sheet.column_dimensions['E'].width = 6
...
```

重构后
```python
width_conf = dict(
    A=3.25,
    B=1.38,
    C=3.63,
    ...
)
for conf_key, conf_val in width_confs.items():
	sheet.column_dimensions[conf_key].width = conf_val
```

重构的原因可以理解为：
`sheet.column_dimensions['A'].width = 3.25` 其实至少包含两条信息，一条是 ‘A’ 的宽度是 3.25，另一条是如何设置列的宽度，职责过多。

SRP 最终描述：
> “任何一个软件模块都应该只对某一类行为者负责”

#### 反面案例
作者举的一个例子是：
```
┌─────────┐                        ┌──────────┐
│FIN - CFO├──────────┐             │ HR - COO ├─────────┐
└─┬───────┘          │             └─┬────────┘         │
  │   calculatePay   │───┐       ┌───│    reportHours   │
  │                  │   │       │   │                  │
  └──────────────────┘   │       │   └──────────────────┘
                         │       │
                         │       │
                         ▼       ▼
                   ┌──────────────────┐
                   │                  │
                   │   regularHours   │
                   │                  │
                   └──────────────────┘
```
两个问题：
* 如果因为财务部门需求改了 regularHours() 而人力资源部门不需要这个修改会产生问题
* （更容易发生）合并代码冲突

#### 解决方案
有三种解决方案：
```
TODO
```

#### 本章小结
两个层面的不同表现形式：
* 组件层面： 共同闭包原则
* 软件架构：用于奠定架构边界的变更轴心

这里是康威定律的另一种表达，容易理解的表现是软件高层架构会反映组织架构，好比说我们有交易服务和风控服务，就有交易团队和风控团队。这里强调的是即使同一个团队负责的模块内部结构，也会反映**行为者**的组织架构，在这里的案例就是要按财务部门和人力资源资源部门将模块进行拆分。

作者已经明确指出了复用的价值，但是这里仍然把 DRY 的优先级放在了 SRP 之后，也就是说即使 regularHours() 可以复用，我们也应该完全**隔离对行为者的响应**。也许存在编写重复逻辑的风险，但是可以在需求变更时更为轻松。

我觉得这里还是要辩证的来看，作者当然是想用一种更强烈的方式表达自己的观点，因此极为保守地看待需求，即**不同行为者的一切业务逻辑终将发生分化**。然而倘若 regularHours() 真的是一种跨业务的四海九州亘古不变（或者至少是大领域级别）的 “真理逻辑” 呢？这种场景如果在 A 模块进行了修改而未在 B 模块修改反而可能产生不一致问题。

另一个现实的问题是作者的探讨**假设了不同行为者的业务逻辑是完美隔离并且一成不变的**，如果实际假设不成立，比如确实业务上未进行完美隔离，那么这也会对应用 SRP 造成困扰。

当然这也只能富有经验的设计者才能好好把握，如果用一言蔽之，简单的指导原则对开发者进行要求和管理，SRP 是合理可行的。

### 第 8 章：OCP: 开闭原则

> “设计良好的计算机软件应该易于扩展，同时抗拒修改”
> 
> aka. “一个设计良好的计算机系统应该在不需要修改的前提下就可以轻易被扩展” 

这个原则纯粹是目标声明式的，十分缺乏指导意义。

#### 思想实验
> 好的架构设计会使变更需求时旧代码的修改降至最低

> 为了实现这个目标，可以应用 SRP 和 DIP

这里明确表达了 SOLID 这五个原则并非独立正交，那么哪一个才是第一性原理呢？

> “如果 A 组件不想被 B 组件上发生的修改所影响，那么就应该让 B 组件依赖于 A 组件”

#### 依赖方向的控制
又见 DIP 依赖反转。

#### 信息隐藏
说白了就是都依赖于抽象，从而从各个方向屏蔽实现细节。

#### 本章小结
> “实现方式是通过将系统划分为一系列组件，并且将这些组件间的依赖关系按层次结构进行组织，使得高阶组件不会因低阶组件被修改而受到影响。”

这里倒是进行了具有指导意义的说明。

### 第 9 章：LSP: 里氏替换原则

子类的定义：
> Let q(x) be a property provable about objects x of type T. Then q(y) should be true for objects y of type S where S is a subtype of T.

子类和泛型是多态的两种形式。

#### 继承的使用指导
简单地说就是子类应在父类能出现的任何地方替换父类（可替换性）。

#### 正方形/长方形问题
如果定义正方形为长方形的子类，将违背 LSP，因为：
* 长方形类的高和宽独立
* 正方形类的高宽不独立

因此正方形类无法在所有处理长方形类的地方替换长方形类。

这是一种建模或者说朴素面向对象思想带来的子类问题。

##### 协变
LSP 另一个复杂性就得提到协变的概念，可替换并不是 trivial 的。

定义 A<:B 表示 A 是 B 的子类

###### 泛型
若 C[T] 是以 T 为参数的泛型，有三种可能：
* 协变：C[A]<:C[B]
* 逆变：C[B]:>C[A]
* 不变：C[A]、C[B] 互不为子类

对于数组 A[] 和 B[]：
* 协变：只读
    > 可以把 Dog 放入 Animal[]，但是不能放入 Cat[]
* 逆变：只写
    > Animal 中可能读出 Dog[]
* 不变：读写

C++ 中指针和引用是协变的。

###### 函数
定义 A=>B 表示输入 A 输出 B 的函数，那么有定理：
**如果 A2<:A1 并且 B1<:B2，则 A1=>B1 <: A2=>B2**

也就是说如果要一个函数是另一个函数的子类，那么**返回值必须更严格（其实是不更宽松）**，而**形参要更宽松（其实是不更严格）**。因此如果泛型 C 是函数，输入应该逆变而输出是协变。


而我们常说的一个类，就即包含数据又包含函数，那么 LSP 意味着不仅子类的数据可以替换父类的数据，子类的函数也应该可以替换父类的函数。

这就要求子类函数的返回值应更严格，形参更宽松。

主流的面向对象语言中, Java和C++允许返回值协变，C#不支持。
允许参数逆变的面向对象语言并不多——C++和Java会把它当成一个函数重载。

更复杂的是这里有争论，Eiffel 语言明确拒绝了 LSP，允许形参协变。
维基的[例子](https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98)，“猫调用问题”：

父类函数版本
```java
class AnimalShelter {
    void putAnimal(Object animal) {
       ...
    }
}
```

子类函数形参逆变的版本
```java
class CatShelter extends AnimalShelter {
    void putAnimal(Object animal) {
       ...
    }
}
```

子类函数形参协变的版本
```java
class CatShelter extends AnimalShelter {
        void putAnimal(Cat animal) {
           ...
        }
    }
```

协变的版本在 LSP 的角度来看，丧失了类型安全，因为 CatShelter.putAnimal 拿去替换 AnimalShelter.putAnimal 的话，会可能收到 Dog。
但是从另一个角度来看，CatShelter 本来就不应该有狗放进来，这样看来用类型来限制也似乎并无不可。当然也可以认为这里是正方形/长方形问题的另一种表现。



#### LSP 与软件架构
强调依赖于接口，类之间有可替换性。

#### 违反 LSP 的案例
配置（变化的部分）分离。

### 第 10 章： ISP: 接口隔离原则
TODO

#### ISP 与编程语言
动态类型语言如 Ruby 和 Python 不需要显式使用接口声明（契约直接分散在代码里），鸭子类型，天然多态，因此比静态语言更灵活，更松耦合。

当然 Ruby 和 Python 里也是需要 import 的，只是从编译和部署的角度来看，仅修改实现细节确实不需要引起依赖方的重新编译或重新部署。

#### ISP 与软件架构
> “任何层次的软件设计如果依赖于不需要的东西，都会是有害的。”

细节就属于不需要依赖的东西，接口、约定是需要依赖且必须依赖的。
这里还是重点强调编译和部署解耦。

#### 本章小结
> 声明创造出源代码之间的依赖关系。而对这种关系的管理是软件架构设计的核心问题之一。

应该说当前应用广泛的微服务实践正是这种原则的极致表现，完全做到各模块：
* 独立开发
* 独立编译
* 独立部署
而在模块内部，已不存在拆分编译和部署了，因此一般开发者也无需关注这个点。

但是对于面向客户的单体巨石软件，可能还是需要多考虑独立编译和独立部署的事情。

### 第 11 章：DIP: 依赖反转原则
主要关注易变模块，应多依赖抽象而非实现。还是老生常谈的依赖于抽象。

#### 稳定的抽象层
> “接口比实现更稳定。”

#### 工厂模式
> “源代码依赖方向永远是控制流方向的反转”

#### 具体实现组件
> “不可能完全消除违反 DIP 的情况，将其与系统的其他部分隔离即可”

因为各模块需要一同工作，具有内在的关系性，所以完全解耦是不现实的，最终也需要一个控制者让他们协作起来。

#### 本章小结
> “在系统架构图里，DIP 通常是最显而易见的组织原则”

> “跨越边界的、朝向抽象层的单向依赖关系则会成为一个设计守则──依赖守则”