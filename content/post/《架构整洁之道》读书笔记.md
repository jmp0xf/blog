+++
author = ""
date = "2020-05-14T01:50:00+08:00"
description = ""
draft = false
highlight = false
tags = []
title = "《架构整洁之道》读书笔记"
categories = ["架构"]
tocCollapseDepth = 2
+++

## 第 1 部分: 概述
### 第 1 章: 设计与架构究竟是什么
> 架构即设计

#### 目标是什么
> “软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。”

##### 问题到底在哪里
> 工程师（有意无意地）自我欺骗：“我们可以未来再重构代码，产品上线最重要！” ── P9

这可能需要制度的变化才能有所改观，指标需要重定义。

> “无论是从短期还是长期来看，胡乱编写代码的工作速度其实比循规蹈矩更慢。” ── P9

> “如果你觉得好架构的成本太高，那你可以试试选择差的架构加上返工重来的成本。” ── 序言 XII

> “想要跑得快，先要跑得稳。”

这里可能道理大家都懂，但是缺乏具有实操性的指导原则：都知道要适应变化，但是又如何保证不**过度设计**呢？什么是过度设计，比如力求一切可变灵活，那肯定是过度设计。

举一个简单例子，我们现在有很多基于 IP 不变假设的设计，如果一开始就试图适应可变 IP，需要花费相当可观的开发人力；但是如果不适应，一旦 IP 需要变更，将是一场灾难。

如何识别未来的潜在变化是个永恒的议题。如果没有明确的指导方法，仅靠一切尽在不言中，就难以长久维持良好的架构（设计）。


实践矩阵

| | 开发快 | 开发慢 |
| --- | --- | ---|
| 好架构 | **我们想要的**  | 通常选项
| 坏架构 | 通常选项  | 

实践发现，我们的困扰正是来自于二者不可得兼。如何才能开发又快架构又好呢，目前看来，只能多读书多练习多总结，输出更多的经验模式，才更容易扩展复制成功的架构。



### 第 2 章: 两个价值维度
> 软件的实际价值由两个维度体现：行为和架构

#### 行为价值

#### 架构价值
> 软件的 “软”，“不言而喻，是指软件的灵活性”

> “软件应该容易被修改” 
“变更实施的难度应该和变更的范畴（scope）成等比关系，而与变更的具体形状（shape）无关”


#### 哪个价值维度更重要
> 行为价值并非比架构价值更重要

这个得看赛场，有些赛场可能就是 “天下武功，唯快不破”。比如创业公司甚至可能撑不到良好架构获取真正价值的那一天就已经死亡。但是要注意，本书作者也并没有下结论说架构价值比行为价值更重要。

#### 艾森豪威尔矩阵
推荐排序

| | 重要 | 不重要 |
| --- | --- | --- |
| 紧急 | 1 | 3
| 不紧急 | 2 | 4

> 业务部门和研发人员经常犯的共同错误就是将第三优先级的事情提到第一优先级去做。

> 平衡系统架构的重要性与功能的紧急程度这件事，是软件研发人员自己的职责。


#### 为好的软件架构而持续斗争
> “公司内部的抗争本来就是无止境的”

这句我赞同，其实需要各方的尽力竞争才能形成最优的合作。内耗是固有存在的，就像做功永远会有能量损失。但是个人认为这个部分**可以优化**。这里可能业务部门和研发人员的目标可以有一定的融合。有点像 Google SRE 实践中，让运维与开发的目标适度统一，其实本来就不必对立。比方说如果运维的目标就是稳定，那就不能允许开发进行变更；但开发人员只关注功能发布，就需要频繁变更。那么 Google 的做法是设置错误预算来调和双方目标。

## 第 2 部分: 从基础构件开始: 编程范式
> “直到今天，我们也一共只有三个编程范式，而且未来几乎不可能再出现新的”

### 第 3 章: 编程范式总览
| 范式 | 限制和规范 | 关注点 | 手段 |
| --- | --- | --- | --- |
结构化编程 | 程序控制权的直接转移（goto 语句） | 功能性 | 各模块算法实现基础
面向对象编程 | 程序控制权的间接转移（函数指针） | 组件独立性 | 多态跨越架构边界
函数式编程 | 程序中的赋值（赋值语句） | 数据管理 | 规范和限制数据存放位置与访问权限

> “我们过去 50 年学到的东西主要是 ── 什么不应该做。” ── P51

代码是写给人看的，而人的认知能力有限（内存太小），因此需要保持尽量简单（KISS）。不同范式其实表达能力是一样的（图灵等价），那么其实说三种范式是限制（只是作者的关注点），就不难理解，其实是一种避免多样、混乱和复杂的方式。

> “无论是三种编程范式还是微服务架构，它们都在解决一个问题 ── **分离控制和逻辑**” ── 推荐序一 V

逻辑描述做什么，也就是不变的部分。
控制描述怎么做，也就是变化的部分。

编程范式的解耦方式
* 面向对象：委托、策略、桥接、修饰、IoC/DIP、MVC
* 函数式编程：修饰、管道、拼装
* 逻辑推导式编程：Prolog


### 第 4 章: 结构化编程
> “goto 语句的**某些**用法会导致某个模块无法被递归拆分成更小的，可证明的单元，这会导致无法采用分解法来将大型问题进一步拆分成更小的、可证明的部分。”

哪些用法？

> 系统设计层次混乱，也可以看作一种 “goto” 陷阱 ── 推荐序二 VII

> “结构化编程范式中最有价值的地方就是，它赋予了我们创造可证伪程序单元的能力。”

> 功能性降解拆分仍然是架构设计领域最佳实践之一。

正是因为可递归降解，通过无法证伪（通过测试）子单元函数，从而可推导整个程序正确。


### 第 5 章: 面向对象编程
#### 封装
> “这个特性其实并不是面向对象编程所独有的。”

> 相比于 C，C++、Java、C# 这种 “面向对象” 语言反而削弱了封装性。
really?

> “我们很难说强封装是面向对象编程的必要条件。”

#### 继承
> C 也可以做继承（有些投机取巧）

> 但是面向对象编程对继承提供了易用便利

#### 多态
> C 也可以做多态，“归根到底，多态其实不过就是函数指针的一种应用。”

> 但是面向对象编程确实使多态更安全更易用

##### 多态的强大性
> 多态可以实现插件式架构，而面向对象编程使得插件式架构可以在任何地方被安全地使用。

##### 依赖反转
> 依赖关系和控制流相反则称为**依赖反转**。

> 通过利用面向对象编程语言所提供的安全便利的多态实现，可以完全控制所有源码依赖关系，不受系统控制流的限制

重点是依赖于抽象，无论高低层次。这样也就实现了控制与逻辑分离。抽象=逻辑，实现=控制。

> 完全控制源码依赖关系的好处是可以独立编译，进而推导出可以独立部署，进而推导出可以独立开发
切入角度刁钻。

#### 小结
> “面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。”

### 第 6 章: 函数式编程
> “一个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量。”

> “可变状态组件的逻辑应该越少越好。”

> 举了 binlog CRUD=>CR 的例子

可参考 [日志：每个软件工程师都应该知道的有关实时数据的统一抽象](https://github.com/oldratlee/translations/blob/master/log-what-every-software-engineer-should-know-about-real-time-datas-unifying/README.md)
