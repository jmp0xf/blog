+++
author = ""
date = "2018-04-28T16:02:00+08:00"
description = ""
draft = false
highlight = false
tags = ["开发"]
title = "记我的第一次 - 开发篇"
categories = ["创业"]
markup = "mmark"
tocCollapseDepth = 2
+++


## 设备

* Mac

    > 既有 Windows 的图形界面，又有 Unix 系 的 Shell，完美
* Dell U2414H 显示器

    > 23.8 吋，窄边，三轴可调，价廉物美，爆款
* 保友 Ergonor 金卓人体工学椅

    > 久坐不累，几乎已成为初创公司标配
* 机械键盘

    > 对于 Mac，Matias 家的机械键盘可能最为适合，有线/无线都有

> 不要误会，资本家当然不是要讨好员工，资本家只是想让员工干活更有效率，创造舒服的工作环境束缚员工，让他们不想离开，从而最大化企业利益。

## 服务
### 主机
PaaS 太束手束脚，不考虑。国外服务器的话，基本上就只在 Linode 的 VPS 和 AWS 的 EC2 中做选择。
经过多次不严格的测试，Linode 的日本节点比 AWS 的日本节点连接我们业务中的主要客源国的速度要更均衡更稳定。

Linode 的功能也比较丰富，自带 Monitor / Node Balancer / Backup，用起来也很便捷省心，你只要交钱就是了。

> Linode 的 IP 池是被 GFW 墙的重灾区，当然我们使用 CDN，不担心国内用户无法访问，但是远程登录还是不大方便，只要向客服提出申请就可以更换 IP，也很方便。
>
> 测速时需注意，许多测速工具为 ping 工具，若想得到完整的 RTT 时间，还要从服务器 ping 一下 CDN 才能计算出来。当然如果使用的是 HTTP 工具就方便多了。


### CDN
CDN 不仅可以在某种程度上对网站进行加速，还可以隐藏服务器的真实 IP，一定程度上增加了安全性。
Incapsula 的香港节点对于中国地区来说更快，而 CloudFlare 对于世界其他地区来说要比 Incapsula 好。于是我们使用 AWS Route 53 进行分区域解析，中国 IP 解析到 Incapsula 上去，
而其他 IP 解析到 CloudFlare 上去。

CloudFlare 的功能比 Incapsula 强大许多，有独有的图片加速 Mirage、Javascript 加速 Rocket Loader™，以及智能路由多层缓存 Argo 等功能，现在更是允许在节点部署 JavaScript Service Workers。
百度云加速和 CloudFlare 合作后，双方的节点资源共享，CloudFlare 国内的节点就是百度的，CloudFlare 也可以帮助要使用国内 CDN 节点的用户申请 ICP 备案。

根据我们实际使用的经验，无论是 Incapsula 还是 CloudFlare，一年之中总有那么几天里，有数分钟到数小时不等的不稳定时间，因此，如果对可用性要求极其高的用户，可能要另择方案。

> 体量大，预算足的话可考虑 Akamai

### DNS
我们选择了 AWS Route 53，功能十分强大，可以根据地理区域/延迟时间/加权/服务器心跳进行解析。

> DNSPod 也是创业公司常用的 DNS 解析服务，以前的话更推荐使用 DNSPod 国际版，可惜现在暂停使用了

### 云存储
基本上没有什么好选的，国内七牛云，国外 AWS S3，我们是在后端根据用户地理位置加载更适合的文件 URL。

### 邮件
邮件服务商很多，我们综合考虑后觉得国外的 Mailgun 是性价比最高的，国内的 SendCloud 也很不错。Mailgun 上可以购买信誉度更高的独立 IP，使用越久的 IP 的信誉度也会更大，所以好的发件 IP 是需要 “养” 的。江湖上还流传着上主流客户端白名单的方法，我们势单力薄，无力一试。有条件的话建议可以自觅方式提前预热发件 IP 和域名，而不用等到业务开始。经过玄学测量，对于某些客户端，某些邮件服务商发出的邮件会有天然的信誉加成，所以可以考虑混用，根据邮箱域名路由到不同的发送服务上去，还可以根据投递状态进行 Round-robin。Mailgun 还提供验证邮箱地址是否真实的 API。

> 自动触发邮件、营销邮件、人工邮件最好使用不同的子域名

### 支付
初创公司自行整合多种支付 API 非常麻烦，Stripe 会让问题迎刃而解，不仅无缝集成多种支付方式（包括储蓄卡、信用卡及 Alipay 等），交互动画更是独步天下，一级爽滑，体验极佳（甚至是其开发文档）。

> 多合一支付服务服务费较高
> 
> 国内可以选择 Ping++

### 客户支持
Zendesk

> 国际化比较麻烦

### 短信服务
Nexmo

> 服务区域和价格都能让人满意

### 监控和分析

#### 性能监控
New Relic

#### 异常监控
Sentry（前端是 Raven.js）

#### 行为分析
* Google Analytics[^blog]
* 百度统计

    > 虽然 GA 在国内实际上可以使用，但为了保险，还是用了百度

* Inspectlet/Hotjar

    > 这类服务可以将用户的整段访问行为还原成录像进行展示，非常有趣，有一种窥探的快感，比冰冷的统计数据能更进一步地了解用户行为。有点像野生的可用性测试。

[^blog]: 博客的跳出率计算需要进行修正，方式是对停留时间进行阈值计算，参见 [跳出率 - Google Analytics（分析）帮助](https://support.google.com/analytics/answer/1009409?hl=zh-Hans)

### 网页测速

#### 网络线路
* [17CE](https://www.17ce.com)
* [卡卡网](http://www.webkaka.com)
* [monitive](https://monitive.com/uptime-monitoring-test/)
* [host-tracker.com](https://www.host-tracker.com/InstantCheck/Create)
* [CA App Synthetic Monitor](https://asm.ca.com/zh_cn/ping.php)

#### 网页加载
* [PageSpeed Insights](https://developers.google.com/speed/pagespeed/insights/)

##  技术
### 语言
Web 开发的候选语言是 Ruby（on Rails）、Python、Java，PHP，当然还有当时特别火的 Javascript（Node.js）。

PHP 历史包袱沉重且风格丑陋，而 Node.js 当时极不成熟，其鼓吹的高并发对我们来说也没什么用；

Ruby 应该说在当时是 Web 开发的王者，具有超一流的元编程能力，我曾经看过有人这么形容，但是出处找不到了，大意就是说 Ruby 开发到底有多爽呢？
假如说使用 Python 就像是在干一位姑娘那么爽，那使用 Ruby 就像是对一个姑娘为所欲为那么爽。然而坏消息是，Ruby 职位在国内招人极其困难，基本上都需要自行培养。

再考虑到 Ruby、PHP、Javascript 几乎只专精于 Web，生态应用范围太窄，基本上候选就只剩 Java 和 Python。

Java 在生态和周边工具方面极其成熟，只是我个人总觉得 Java 特别笨重，干点什么事情都要写特别多的东西，感觉总是不得劲。Java 8 当时也还没发布，写起来确实没有 Python 舒服。
总体来说就是没什么毛病，但也很难让人眼前一亮。

Python 使用 “鸭子类型”，函数是一等公民，在语言层面具有部分诸如元类的元编程能力，灵活强大，语句简练易读，生态应用极其广泛也足够成熟，从日常脚本到 Web 开发到爬虫再到机器学习都能胜任。再考虑到可选的 Web 框架后，
最终我们选择 Python 作为后端开发语言。

#### 心得体会
##### 灵活 vs 安全
Python 这样的语言有些过于自由。比如说 Python 允许函数随便返回什么东西，输入不同时，返回来的东西是什么都可以，数量和类型都允许发生变化。序列也是什么都能装进去。
再比如说 Python 中的类与对象由于 “元编程” 能力，可以很容易实现出各种超出语言本身期待的行为。这是一种魔法，
经验丰富的开发者可以事半功倍，而经验不足的开发者很可能会玩出问题（没有人指望在不设置交通灯/隔离栏等障碍的情况下维持交通秩序）。

人们经常谈到 “动态一时爽，重构火葬场”，使用 Python 进行团队协作时该问题更加凸显。阅读他人源码时，经常会碰到一个形参完全不知道是什么东西，源码只能自上而下地理解，而无法自下而上地理解。
当然，现在也有 PEP 3107 Function Annotations 加辅助工具来缓解这类问题。

即使在文档完备的情况，这也会加重开发时考虑 context 的负担（在我看来，这属于一种信息压缩，只要达成共识，简单的语句可以蕴含丰富的含义），增加了团队协作时出错的概率。
更糟糕的是，这些错误只有在运行时才能被发现。

当然你可以说不犯错的话，这种自由带来的灵活强大就很棒棒。但我觉得这种 context 负担就类似于过程式语言赋值的副作用，没有人可以保证这种副作用一定会得到良好的处理。
函数式语言正是因为没有这种副作用的负担，使得程序紧凑，不易出错。

实际上每种语言的表达能力是等价的，Python 这种自由度很高的语言有太多方案去达成目标，但也很容易写出张牙舞爪的怪物出来。
严格的、看似不那么灵活强大的语言通常会加入许多约束，而这些约束也许会降低开发效率，但是也会强迫开发者去思考，并且通过限制统一开发风格。
使用这类语言开发会感到要进行很多冗余的表达，但恰恰是这些冗余的表达可以在某种方面确保该表达确实是你想要的语义，而精简的表达则缺乏冗余进行校验，容易出错。
Java 里很多严格麻烦啰嗦的事情都是在语言层面确保事情正确地进行，因此一般认为 Java 特别适合大型团队协作，开发高质量保证的大型项目。
约束导致有序，有序通向可靠。

正因如此，虽然 Python 这类语言有许多强大的高级特性，却一直也有声音警告反对过度使用高级特性，除非你很清楚自己在干什么。
当你发现很难将其改写为另一种语言时，那可能说明滥用高级特性已经病入膏肓了。

总之各种语言都有各自擅长的维度，就 Python 而言，开发效率（也可能是前期开发效率）是其最大的优点。
但有得必有失，选择某种语言必须是特别看重其优点，又要能坦然接受其缺点。
不要做语言的奴隶，最好语言之争毫无意义，世间没有万能药，只有适合的场景。



##### 元编程
编程如果只遵循一条原则的话就是 DRY（Don't Repeat Yourself），想要 DRY 就得尽可能重用代码，使其共享某种模式，一处定义，多处引用，
对变化的部分和重用的部分进行显式分离，保持正交。有时候模式本身还有模式，也就是模式的模式，那么元编程就有了用武之地。

元编程总是可以有其他非语言层面的方式实现，比如自己发明 DSL 编译到目标语言，这样反而运行速度更快。但从实用角度来说，在语言层面上实现元编程，确实很爽，一方面开发人员一般不会因为一个可能就用几次的元编程模式去写一个 DSL 编译器，
其次在语言中实现元编程可以将模式描述信息和相关业务功能的上下文代码物理上放置在一起，保持代码结构的紧凑。

但是毕竟，可以认为这也只是一个语法糖而已，语法糖很容易让人迷失在便利之中看不清事物的本质。我现在就不太喜欢 Vue 推崇的语法糖模式的阉割渲染逻辑（为什么要用 HTML 写逻辑，只是因为比较顺手吗？），反而倒是喜欢 React 重量级但完备的抽象，将渲染逻辑彻底地分离。

##### 循环引用
通过一些简单的技巧，Python 实际上是允许循环引用的，这很容易让人不仔细思考依赖关系。
因此一旦遇见循环引用错误，一定不要绕过，此时应该仔细重构。

实际开发中，有些循环引用难以避免。这也是为何 Python 的 ORM 定义外键时一般允许使用字符串进行指定，一方面是允许 lazy loading，另一方面也是可以绕开难以避免的循环引用。
信息的双向流动会引入循环引用。比方说模型 A 一对多关系到模型 B，那么 B 到 A 有一个外键关系，B 必须依赖于 A；然后我们又希望能直接从 A 的方法中获得所有与其关联的 B， 这样 A 会依赖 B，出现循环引用。当然我们可以额外使用函数而不是方法来完成这个功能，但这样反而不容易让人觉得是一个好设计。即使从内聚和耦合方面思考，也很难明确 A 不应该 “知道” B 的存在。所以有时候为了某些特别的需求，应该允许有节制地反范式。
还有些不可避免的循环引用来自于第三方包。比方说某第三方包允许你自定义的模块/类对包的某部分功能进行定制，然而自定义的模块/类又必须依赖该第三方包以满足接口要求，这很容易隐含循环引用。

##### 多继承
Python 中允许多继承，只要理解并正确利用 MRO（Python 的实现回避了菱形继承的歧义问题），Model Mixin 可以更便捷优雅地实现组合模式。
这是 “优先组合而非继承” 的一种实际用例。

##### GIL
Python 有个缺点是常见实现[^pyston] CPython 中的 GIL 全局解释锁，多线程无法利用多核能力，因此并发一般用多进程解决，造成内存占用较高。

[^pyston]: 目前其他的常见实现还有 PyPy 和 Jython，其实当年还有 Dropbox 雄心勃勃的 Pyston，当时被寄予厚望，现在已基本流产。

#### 风格规范与编码指南
我认为应该严格区分所谓 “风格规范” 与 “编码指南”，前者不同的编码选择对编译器或解释器来说是完全等价的，而后者则并非如此。

以下是综合 PEP 8、Google Python Style Guide 和 The Pocoo Style Guide 得出的风格规范和编码指南：
* [Python 风格规范](/post/python风格规范/)
* [Python 编码指南](/post/python编码指南/)

### Web 框架
几乎没有犹豫，除非做玩具，Django 几乎是最适合快速开发的选择。生态社区成熟，开发活跃，文档优异。文档厉害到从开发思想到最佳实践和实际部署甚至可能出现的实际开发问题都描述得一清二楚，我再也没见过第二个如此优异的文档。
Flask、Tornado 等 Micro Framework 难以望其项背。我也用过一些其他号称 Fullstack 的框架，但只有 Django 在很多细节问题上做到了较为完备的解决，如鉴权与授权、国际化、本地化和 URL Reverse 等等。做地理应用还专门有 GeoDjango，牛逼爆了。

很多人觉得 Django 学习曲线太高，其实 Django 主要的组成部分也就是 Model/ORM, URL dispatcher, Middleware, View, Template，无它。虽然现在 Django 可以替换 ORM 和模板引擎，但是我不推荐，除非你确定不需要 Django 随包附赠的可深度订制 CRUD 后台（使用 Django 的 ORM 和模板系统）。数据库 Migration 文件是个讨厌的东西，第三方 App 的 migration 默认不受主项目控制，而有些第三方 App 更新后可能不遵循 migration 的路径，而是直接改写，造成混乱。

Django 乃至 Python Web 框架长期为人诟病的主要原因是其运行速度，实际上在大部分场景下这并不是一个真正的问题。在留学租房领域，单机 Django 估计能撑到垄断全球，
而对于大多数其他业务领域来说，大多数团队也活不到需要深入优化速度的阶段。首先，通常制约 Web 应用的主要因素并非应用代码运行速度，而是 I/O 速度；其次，针对 I/O 优化的各级缓存，像多级漏斗一样筛去大部分前往应用服务器的请求，
可以大大减少后端应用服务器的运行负担。就算你真的野心勃勃一心要搞个大家伙，那么 Instagram 也可以告诉你，Django 或 Python 不太可能成为你成功路上的绊脚石。相比之下，迭代速度才是创业团队更需要追求的。

这里要稍微说一下前后端分离，我们想要的是，前后端在数据上得一致，在开发上分离。前端接收后端的数据，总得有个地方去指定传递的数据。当前流行的 SPA 是将数据通过异步 Web API 进行传递。
而 Django 这类 MVC 框架则是将数据通过 Python 模板引擎传递，这相比于 SPA 模式主要问题在于调试痛苦，模板虽然是由前端人员编写（实际上后端也会参与），却又得由后端启动，前端人员难以独立便捷调试，可能需要安装一大套后端环境。
即时运行起来，前后端问题混合在一起，可能难以追踪。反观 SPA，甚至可以做到前后端分开独立部署。
我们之前就有前端人员反复抱怨这一点。当然如果有良好的 Mock 设施的话，其实此问题也可以得到缓解。
另一个小问题是前端人员需要学习特定的模板语言。
话虽如此，SPA 却有非常严重的 SEO 问题（SSR 依然没有那么美好），在我们的业务领域中是不可接受的，所以即使了解 SPA 前后端分离的好处，也不得不继续使用传统后端 MVC Web 框架。而所谓的调试部署问题、开发语言问题，对于小团队/小项目，全栈开发人员也都不算什么大问题。

比如说表单验证，需要保证前后端一致。Django 的默认本质上是一种后端写前端的方式，是在用 Python 在编写 Specification，然后生成前后端代码，使得其数据一致。

### 数据持久化
PostgreSQL vs MySQL

PostgreSQL相对于MySQL的好处

对SQL标准和事务的完整支持
良好的空间搜索支持
支持hstore和json字典存储

当时 NoSQL 盛行 甚至不使用外键
有些情况也必须使用 NoSQL 范式
比如说订单关联用户和 Property 不适合使用外键
不然一删全删

使用软删除
也有更牛逼的 package 可以 revert 的
http://scottsmerchek.com/2015/08/03/taking-the-d-out-of-crud/

### WSGI Server
* uWSGI

    > 性能强大
* Gunicorn

    > 配置简单

### Web Server
* Nginx
* Openresty

    > Nginx 加强版

 我们使用的是 uWSGI + Openresty，还可以方便地选配各种 WAF。

#### 消息队列
没得选，就是 Celery
Celery 没有绝对的优先级 待查
只能设置不同的 worker 来变向处理
优先级越高就给更多的 worker
https://blog.csdn.net/orangleliu/article/details/37967433

#### 全文搜索
ElasticSearch

https://github.com/dolphinfafa/dorm/issues/1498

* Front-end
* 访问速度优化

* 挑战
    * 多语言 国际化和本地化
    * 首先单复数问题没那么简单
    * 再就是分为静态翻译和动态翻译
    * 前端翻译和后端翻译
    * 多语言搜索
    * 多语言标签
	* 带样式的翻译就比较麻烦了 得整个 HTML 一起翻译

优化 prefetch_related select_related

Airbnb 是个活生生的好教材，有很多可以学习
多语言跳转的方式

[Always put side effects last](https://swizec.com/blog/always-put-side-effects-last/swizec/8057)

动态生成头像

租期期限的完备设定

算月价是有个注意的陷阱 周余了天就按七分之一周价每天算  但是算月是按自然月算 而非30天一月

要考虑对各个字段考虑为空时的处理及显示 denorm
为空退化以及自动计算

网页完全 cache 很困难 动态的东西难以cache 尤其是以请求元信息作为相异 key 的

响应式不是万能的，只能适用于一般的信息展示，如果涉及的交互，则很难指望响应式框架能带来什么好处
如果有大量的交互区别，还是应该单独设计移动站点

反爬虫

### 服务器取名